\begin{apendicesenv}

\chapter[Suporte Tecnológico]{Suporte Tecnológico}
É apresentado a seguir um compilado das principais ferramentas que foram utilizadas no desenvolvimento do \textit{framework} para geração de testes unitários. Com a finalidade de melhorar a organização, os recursos tecnológicos foram divididos em categorias: Geração de Teste Unitário e Engenharia de Software. A primeira refere-se aos suportes que foram utilizados na construção do \textit{framework}, enquanto a segunda categoria auxiliaram o gerenciamento e desenvolvimento do software e documentação relacionada.

\section{Geração de Teste Unitário} \label{suporteGeracao}
Os recursos tecnológicos identificados como capazes de auxiliar no desenvolvimento do \textit{framework} estão apresentados a seguir:

\subsection{Flexc++}
Flexc++ é um analisador léxico escrito por Frank B. Brokken, gerente de segurança em TI e conferencista na \textit{University of Groningen}, Holanda\cite{flexcpp2015}. O desenvolvimento desse analisador começou em 2008 e é mantido até hoje. Atualmente está na versão 2.03.03, é mantido por: Frank B. Brokken, Jean-Paul van Oosten e Richard Berendsen \cite{flexcpp2015}. No entanto, a versão utilizada foi a 1.05. 
 
\subsection{Bisonc++}
Bisonc++ é um gerador de parsers capaz de converter uma gramática de contexto livre em uma classe \textit{parser} em C++ \cite{bisoncpp2015}. Bisonc++ foi escrito e é mantido por Frank B. Brokken, da \textit{University of Groningen}, Holanda. Bisonc++, diferentemente do Bison, fornece uma classe em C++ após ser compilado para que possa ser usada. Bison fornece um código em C \cite{bisoncpp2015}.
\par
\indent Ambas as ferramentas mencionadas, Flexc++ e Bisonc++, são muito utilizadas no contexto de compiladores \cite{aaby2004} e foram úteis por darem suporte ao reconhecimento léxico e à interpretação de linguagens. Para a geração de testes é necessário o reconhecimento de palavras-chave capazes de revelar informações sobre os métodos a serem testados. Também forneceram suporte na interpretação dos arquivos de código fonte, bem como no desenvolvimento de um \textit{parser}, cujo produtos finais foram os testes gerados.

\section{Engenharia de Software}
As ferramentas a seguir foram utilizadas para auxiliar no gerenciamento e na implementação, bem como na documentação associada. Buscou-se aplicar os conhecimentos adquiridos no decorrer do curso de engenharia de software para apoiar o processo, tanto em tecnologia, quanto em práticas de desenvolvimento de software.

\subsection{Gerência de Projetos}
No que tange à área de gerência de projetos, as seguintes ferramentas serão utilizadas:

\subsubsection{Trello} 
Serviço \textit{online} que permite o gerenciamento de projetos e tarefas por meio de quadros e listas. Trello possui uma interface simples que possibilita anexar arquivos, compartilhamento de conteúdo por equipe, adicionar responsável em tarefas,  entre outras funcionalidades. Embora haja recursos pagos, não há necessidade de pagamento para utilizar essa ferramenta \cite{trello2015}.
\par
\indent O Trello centralizou as informações gerenciais do projeto como as tarefas a serem executadas, descrição e prazos. 

\subsubsection{Bizagi Modeler}
Ferramenta gratuita para modelagem de processos que respeita a especificação BPMN (\textit{Business Process Modeling Notation}). Bizagi fornece suporte de ajuda para usuário com guias e tutoriais, além de permitir a edição compartilhada de processos entre suas funcionalidades \cite{bizagi2015}. Foi utilizada a versão 2.9.
\par
\indent O Bizagi Modeler permitiu a modelagem de um processo que guiou o trabalho de conclusão de curso. O modelo desse processo possibilitou a visualização e o entendimento do processo seguido.

\subsection{ZenHub}
Extensão de navegador capaz de adicionar recursos de gerenciamento na interface do GitHub cite{zenhub}. Com isso, foi possível centralizar o gerenciamento do projeto no repositório do código.



\subsection{Desenvolvimento de Software}
Em relação ao desenvolvimento de software, os seguintes suportes foram selecionados:

\subsubsection{Vim}
Vim é um editor de texto configurável construído para permitir a edição de texto de forma eficiente. Essa ferramenta foi criada com base no editor Vi, distribuído com a maioria dos sistemas UNIX \cite{vim}. Licenciado pela \textit{charityware}, Vim é distribuído gratuitamente. 
\par
\indent Esse editor de texto será utilizado para a edição dos arquivos de código fonte.

\subsubsection{Ubuntu}
Distribuição linux, livre e de código aberto. Patrocinado pela Canonical Ltda., Ubuntu utiliza kernel Linux baseado em Debian e é licenciado pela \textit{General License Public} (GPL) \cite{ubuntu2010}. A versão utilizada foi a 14.04.
\par
\indent O Ubuntu será utilizado como sistema operacional padrão para o desenvolvimento do \textit{framework}.

\subsection{Gerência de Configuração de Software e Requisitos de Software}
Para dar suporte ao desenvolvimento, automatizando o máximo possível determinadas tarefas, as seguintes ferramentas foram escolhidas para a gerência de configuração de software:

\subsubsection{Git}
Git é um sistema de versão distribuído de código aberto e gratuito. Criado em 2005, Git foi desenvolvido visando manter velocidade e eficiência para pequenos e grandes projetos \cite{git2015}. 
\par
\indent O Git permitirá o versionamento do código fonte, bem como da monografia, proporcionando controle das versões e possíveis resgates de informações.

\subsubsection{GitLab}
GitLab é um serviço de hospedagem de projetos de software que utiliza Git como controle de versão. GitLab fornece, entre suas funcionalidades, o gerenciamento de \textit{issues}, uso de \textit{wiki}, controle de permissão de \textit{branchs}, revisão de código e utilização gratuita de repositórios privados \cite{gitlab}.
\par
\indent O GitLab será um local central, onde diversas informações sobre o projeto serão encontradas, inclusive o próprio código. É nesse centro de informações do projeto que também estarão relacionados os requisitos de software, e sua rastreabilidade com as histórias de usuário.

\subsubsection{Jenkins}
Jenkins é um sistema de integração contínua capaz de gerar \textit{builds} periódicos e automáticos, facilitando a integração de alterações em um projeto. Multi-plataforma e software livre, Jenkins permite a integração com diversos \textit{plugins} de forma a facilitar sua customização \cite{jenkins2015}.
\par
\indent O Jenkins garantirá que o software em desenvolvimento esteja sempre sendo testado e integrado, proporcionando que essas atividades não sejam feitas tardiamente. Auxilia, assim, os desenvolvedores a perceberem problemas mais cedo e reagirem rápido.

\subsubsection{Vagrant}
Vagrant é uma ferramenta capaz de gerenciar a criação de máquinas virtuais para ambientes de desenvolvimento. Sua utilização proporciona a automação da instalação e configuração de ferramentas, além de facilitar a padronização dos ambientes de desenvolvimento utilizados por uma equipe de software \cite{vagrant2015}. Inicialmente criado por Mitchell Hashimoto em janeiro de 2010, Vagrant é um software aberto mantido pela atualmente principlamente pela empresa HashiCorp \cite{vagrant2015}. 

A utilização do Vagrant permitirá a padronização do ambiente de desenvolvimento utilizado na implementação do \textit{framework} proposto. Também tornará mais simples a replicação desse ambiente, caso seja necessário.

\subsection{Pesquisa}
Para dar suporte ao andamento da pesquisa e produção da monografia as seguintes ferramentas serão usadas:

\subsubsection{LaTeX}
Criado inicialmente em 1985 por Leslie Lamport, o LaTeX é um sistema de preparação de documentos para composição tipográfica que tem como principal objetivo reduzir o esforço dos autores na formatação de textos técnicos ou científicos. Baseado na linguagem TeX, criada por Donald E. Knuth, LaTeX está disponível como software livre e é mantido pela \textit{LaTeX3 Project} \cite{latex2015}.

\subsubsection{TexMaker}
Editor de texto multi-plataforma para LaTex. Software livre licenciado pela General Public License (GPL), o TexMaker inclui suporte \textit{unicode}, verificação ortográfica, função de auto-completar, visualizador de arquivo em PDF, além do editor para escrita de arquivos LaTex \cite{texmaker2014}. Foi utilizada a versão 4.1.

\subsubsection{Zotero}
Zotero é um software livre (GPLv3), criado e mantido pela \textit{George Mason University}, que tem por finalidade a gerência de bibliografias e materiais relacionados à pesquisa. Entre suas principais funcionalidades estão a geração de relatório de referências e a exportação de bibliografias já formatadas \cite{zotero2015}. A versão utilizada foi a 4.0.28.

\chapter{Resumo do Estudo das Ferramentas Flexc++ e Bisonc++}

\section{Flexc++}
Flexc++ é um analisador léxico escrito por Frank B. Brokken, gerente de segurança em TI e conferencista na \textit{University of Groningen}, Holanda. O desenvolvimento desse analisador começou em 2008 e é mantido até hoje. Atualmente está na versão 2.03.03, é mantido por: Frank B. Brokken, Jean-Paul van Oosten e Richard Berendsen. No entanto, por hora, será utilizado a versão 1.05.

\subsection{Comparativo entre Flex e Flexc++}
\par
\indent Basicamente, a diferença é que Flexc++ tem por intuito gerar código em C++ para que possa ser usado juntamente com programas escritos em C++. Enquanto isso, Flex gera código escrito em C e Flex++ dificilmente dar suporte a todo o pontencial que C++ oferece hoje.

\subsection{Como Executar o Flexc++}

Sua execução se dá pelo comando:
\begin{lstlisting}[language=c, label=apendiceCodigoFlex1, caption=Comando para Execução do Flexc++]
 flexc++ [opções] rules-file
\end{lstlisting}

Onde:
\begin{description}
\item[rules-file:] é o arquivo que contém as regras.
\item[opções:] são opções que o Flexc++ suporta. O intuito delas é customizar algum elemento do \textit{Scanner} ou alguns detalhes, mas que provavelmente não serão usadas aqui. 
\end{description}

\subsection{A Estrutura do Arquivo de Entrada}

A seguir, algumas informações sobre a estrutura do Arquivo de entrada para o Flexc++.

\subsubsection{Nome do Arquivo}

O arquivo pode ser chamado de qualquer forma, no entanto, sua extensão deve ser do tipo .l.

\subsubsection{Corpo do Arquivo}

O arquivo deve possuir duas seções: \textbf{seção de definições} e \textbf{seção de regras}. Essas seções devem estar estruturadas da seguinte forma:

\begin{lstlisting}[language=c, label=apendiceCodigoFlex2, caption=Corpo do Arquivo do Flec++]
seção de definições
%%
seção de regras
\end{lstlisting}
\par
\indent Onde a linha $2$ define o fim e o início entre as seções.

\subsubsubsection{Seção de Definições}

A seção de definições é onde deve-se definir, por meio de expressões regulares, o que será avaliado e como será identificado pelo analisador léxico. A seção deve seguir o padrão sendo o nome do identificador seguido da \textit{regex}. Segue o exemplo de como ficaria:

\begin{lstlisting}[language=c, label=apendiceCodigoFlex3, caption=Seção de Definições]

DIGIT      [0-9]
INTEGER    {DIGIT}
REAL       -?{INTEGER}("."{INTEGER})?

CHARACTER  [a-zA-Z]
LITERAL    \"[a-zA-Z0-9][a-zA-Z0-9].*\"
%%
\end{lstlisting}

\subsubsubsection{Seção de Regras}

A seção de regras é onde deve-se explicitar o que deve ser feito pelo analisador após a identificação dos padrões no texto. A seção deve seguir o seguinte padrão: \textit{padrão    ação}. Ficaria conforme exemplo abaixo:

\begin{lstlisting}[language=c, label=apendiceCodigoFlex4, caption=Seção de Regras]
%%
LITERAL    { cout << "Hello World!"; }
\end{lstlisting}

\subsection{Compilando com o Flexc++}

Para executar a compilação utilizando o Flexc++, supondo possuir um arquivo de entrada flexcpp.l, deve-se:
\begin{enumerate}
\item Compilar o arquivo de entrada com o Flexc++


\begin{lstlisting}[language=c, label=apendiceCodigoFlex5, caption=Comando para Compilar Flexc++]
 flexc++ flexcpp.l
\end{lstlisting}

\item Com isso, serão gerados alguns arquivos. Deve-se alterar a extensão do arquivo lex.ccpara lex.cpp

\begin{lstlisting}[language=c, label=apendiceCodigoFlex6, caption=Comando para Alterar Extensão dos Arquivos]
mv lex.cc lex.cpp
\end{lstlisting}

\item Agora, supondo que o arquivo que utilizará o analisador léxico chama-se analizer.cpp. Assim, para compilar o programa deve-se:

\begin{lstlisting}[language=c, label=apendiceCodigoFlex7, caption=Compilar o Programa]
g++ -o [nome_arquivo_saida] analizer.cpp lex.cpp
\end{lstlisting}
\end{enumerate}

\par 
\indent Pronto! Agora você possui um programa analisador léxico chamado analizer. Para executar use:
\begin{lstlisting}[language=make, label=apendiceCodigoFlex8, caption=Executanto o Programa]
./analizer
\end{lstlisting}

\section{ Bisonc++}

Bisonc++ é um gerador de parsers capaz de converter uma gramática de context livre em uma classe paser em C++. Bisonc++ foi escrito e é mantido por Frank B. Brokken, da \textit{University of Groningen}, Holanda. Bisonc++, diferentemente do Bison, fornece uma classe em C++ após ser compilado para que possa ser usada. Bison fornece um código em C.

\subsection{Pequeno Glossário}
\begin{description}
\item[Símbolo Terminal:] elemento que por si só já define algo. Já possui significado em si mesmo na gramática.
\item[Símbolo Não-terminal: ] elemento que é formado para ter significado completo depende dos símbolos terminais.
\end{description}

\subsection{Como Executar o Bisonc++}
Sua execução se dá pelo comando:

\begin{lstlisting}[language=c, caption=Comando para Executar Bisonc++]
bisonc++ [opções] file
\end{lstlisting}

\par
\indent Onde:
\begin{description}
\item[file:] é o arquivo que contém as regras e ações.
\item[opções:] são opções que o Bisonc++ suporta. O intuito delas é customizar algum elemento do \textit{Parser} ou alguns detalhes, mas que provavelmente não serão usadas aqui.
\end{description}

\subsection{A Estrutura do Arquivo de Entrada}
A seguir, algumas informações sobre a estrutura do Arquivo de entrada para o Bisonc++.

\subsubsection{Corpo do Arquivo}

É formado por duas seções: \textbf{seção de diretivas} e \textbf{seção de regras gramaticais}. Essas seções devem estar estruturadas da seguinte forma:

\begin{lstlisting}[language=c, caption=Corpo do Arquivo do Bisonc++]
seção de diretivas
%%
seção de regras gramaticais
\end{lstlisting}
\par
\indent Onde a linha $2$ define o fim e o início entre as seções.

\subsubsubsection{Seção de Diretivas}
Na seção de diretivas são especificadas algumas opções relativas ao \textit{parser}. Além disso, é nessa seção que se deve definir o nome de todos os \textit{tokens}, exceto aqueles com o nome formado por um único caractere. A inclusão de bibliotecas externas também é feita nessa seção.

\par
\indent Algumas diretivas importantes são:

\begin{description}
\item[start:] designa algum símbolo não-terminal para se a regra inicial.
\item[token:] é utilizado para definir símbolos terminais. Sua sintaxe segue os termos abaixo:

\begin{lstlisting}[language=c,  caption=Sintaxe]
token [<type>] terminal token
\end{lstlisting}
A opção \textit{<type>} é usada quando deseja-se especificar o tipo que será declarado aquele \textit{token}. Alguns nomes não devem ser usados como \textit{token}: ABORT, ACCEPT, ERROR, clearin, debug, error, setDebug.
\item[namespace:] define um \textit{namespace} para a classe \textit{Parser}.
\item[include:] é usada para alterar o \textit{pathname} enquanto a gramática é processada.
\end{description}

\subsubsubsection{Seção de Regras Gramaticas}
De forma geral, uma regra gramatical é definida da seguinte forma:

\begin{lstlisting}[language=c,  caption=Definição de Regra Gramatical]
result:
  components
;
\end{lstlisting}

\par
\indent Onde \textit{result} é o símbolo não-terminal que a regra descreve. Por sua vez,  \textit{components} são vários símbolos terminais e não-terminais que são postos em conjunto, formando a regra. Um exemplo:
\begin{lstlisting}[language=c,  caption=Exemplo de Regra Gramatical]
expression:
  expression '+' expression
;
\end{lstlisting}

\par 
\indent Pode-se também determinar ações para cada símbolo, terminal ou não-terminal, por meio de código em C++:
\begin{lstlisting}[language=c,  caption=Exemplo de Regra Gramatical Utilizando C++]
expression:
  expression '+' expression {
    C++ statements
  }
;
\end{lstlisting}

\par 
\indent Pode-se criar múltiplas regras para o mesmo\textit{result}:

\begin{lstlisting}[language=c,  caption=Exemplo de Regra Gramatical Utilizando Múltiplas Regras]
result:
  rule1-components {
    C++ statements
  }
|
  rule2-components {
    C++ statements
  }
;
\end{lstlisting}

\par 
\indent Há também a opção de deixar um componente vazio. Nesse caso, result pode corresponder a uma string vazia.
\par 
\indent \textit{Regras Recursivas:} é quando o result não-terminal aparece também do lado direto de um componente desse mesmo \textit{result}. Praticamente, todas as regras no Bisonc++ precisam ser recursivas. Há também como utilizar a recursão pelo lado esquerdo. Inclusive é a forma correta. Outra forme possível é fazer a recursividade indireta. Essa pode ocorrer da seguinte forma:

\begin{lstlisting}[language=c,  caption=Exemplo de Regra Gramatical Utilizando Recursividade]
expr:     
  primary '+' primary
|
  primary
;

primary:
  constant
|
  '(' expr ')'
;
\end{lstlisting}

\subsection{Compilando o Bisonc++}
Para executar a compilação utilizando o Bisonc++, supondo possuir um arquivo de entrada bisoncpp.y, deve-se compilar o arquivo de entrada com o Bisonc++. Para isso, utiliza-se o seguinte comando:
\begin{lstlisting}[language=c,  caption=Comando para Compilação do Bisonc++]
bisonc++ bisoncpp.y
\end{lstlisting}


\end{apendicesenv}
