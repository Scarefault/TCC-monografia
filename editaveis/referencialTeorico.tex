\chapter[Referencial Teórico]{Referencial Teórico}
Neste capítulo são apresentadas as bases teóricas para o desenvolvimento do \textit{framework}. O capítulo está organizado em seções. Na seção 2.1 faz-se referência ao contexto de Verificação e Validação de Software. Na seção 2.2 aborda-se uma temática mais específica da qualidade de software, os testes. Traz a motivação para fazê-los, bem como uma descrição sobre os níveis de testes e as vantagens e estratégias de automatizá-los. Na seção 2.3 dicuti-se sobre \textit{frameworks}, sua definição, motivação, vantagens e desvantagens e classificação. Na seção 2.4 explana-se sobre a geração de testes e técnicas de implementá-la.

\section{Verificação e Validação de Software}
Software é uma atividade que requer um processo com o envolvimento de diversas atividades e diferentes pessoas. Essa característica permite a inserção de defeitos no produto final \cite{trodo2009}. Além disso, há o risco de produzir-se algo que não foi solicitado, devido ao mal entendimento dos requisitos\textsuperscript{Falta referência}. Esse conjunto de fatores fez surgir maior preocupação em relação a qualidade de software e, inclusive nesse contexto, é que há o advento da Engenharia de Software, com o objetivo de produzir softwares com qualidade \cite{buenoCampelo2013}.
\par
\indent Tendo em vista o cuidado com o nível dos softwares surge a necessidade de conceituar qualidade no que tange esse assunto. Essa definição é díficil, pois qualidade é um conceito abstrato. Em essência, a qualidade esta ligada a possibilidade de medir determinado atributo e comparar o resultado com padrões já conhecidos \cite{buenoCampelo2013}. No âmbito de software há também o conceito de métricas. Elas são utilizadas para dar visibilidade de determinadas características do produto, de forma a demonstrar o tamanho, esforço e complexidade do software em construção, dentre outros atributos \cite{abreu2011}.
\par
\indent Tendo isso em vista, observa-se que, no que se refere ao software, tem-se como caracterizar a qualidade em dois tipos, na medida em que há características mensuráveis tanto no projeto quanto no produto. São eles: qualidade de projeto e qualidade de conformidade. O primeiro diz respeito aos requisitos, especificações e arquitetura, enquanto que o segundo foca na implementação e sua conformidade com o que foi especificado \cite{buenoCampelo2013}.
\par
\indent A qualidade de software está ligada a atividade de verificação e validação de software \cite{buenoCampelo2013}. A qualidade de software é uma atividade que pertence ao ambiente de gerência, enquanto que a verificação e validação de software é uma prática mais técnica e enquadra-se no desenvolvimento do produto \cite{buenoCampelo2013}. Segundo \citeonline{sommerville2007}, verificação e validação de software é o processo, que certifica que o produto em desenvolvimento atende as especificações esperadas pelo cliente. Essa atividade deve permear todo o processo de produção do software, de forma a garantir que o produto respeita o especificado desde o início. Essa prática evita que a identificação de defeitos seja percebido apenas ao final do desenvolvimento, o que aumentaria os custos do projeto.
\par
\indent Verificação e validação são dois conceitos muitas vezes confundidos. Verificação de software busca analisar se o produto está em conformidade com o que foi especificado. É nessa atividade que observa-se o quão próximo está o produto das especificações dos requisitos, sejam eles funcionais ou não funcionais \cite{sommerville2007}. A validação de software objetiva garantir que o software é o que o cliente solicitou \cite{sommerville2007}. Assim, pode-se conceituar verificação e validação da seguinte forma:
\begin{itemize}
\item Verificação: análise sobre o produto, afim de observar se o produto está sendo feito de maneira certa.
\item Validação: avalia se o produto em construção é o correto em relação às expectativas do cliente.
\end{itemize}
\par
\indent O processo de verificação e validação é responsável por gerar a certeza de que o software está adequado ao que foi pedido \cite{sommerville2007}. Para essa tarefa a verificação e validação utiliza-se de duas abordagens: inspeções de software e testes de software. Inspeção de software é um processo estático, o que significa que não há a necessidade do sistema está em funcionamento. Essa atividade é baseada em revisões, com o intuito de identificar erros e omissões. Toda forma de representação do software é passível de uma inspeção (especificações de requisitos, arquitetura etc), no entanto, o código-fonte é um foco \cite{sommerville2007}. Teste de software é um processo dinâmico, o que exige o funcionamento do software enquanto ele ocorre. Objetiva a demonstração de que o software esta conforme os requisitos, a revelação de falhas ou defeitos no software \cite{sommerville2007} e a prevenção de novas inserções de defeitos \cite{burkeCoyner2003}.

\section{Testes de Software}
Testes de software é uma atividade que compõe o processo de verificação e validação de software. É uma das técnicas mais utilizadas no âmbito de garantia de confiabilidade de software. Em linhas gerais, é um trabalho de abordagem dinâmica sobre o código-fonte. Isso significa que há a exigência do funcionamento do software para que possa ser realizada essa atividade \cite{barbosaEtAl2009}. Essa análise dinâmica abre a possiblidade de identificação de defeitos no código-fonte, bem como a prevenção de inserções de novos defeitos. A produção de testes de software fornece, ainda, impulso para atividades de refatoração, manutenção e medição do software \cite{barbosaEtAl2009}.
\par
\indent Os testes podem ser classificados em \textbf{níveis}. Essa divisão refere-se ao nível de abstração dos testes. Quanto mais próximo do código menos abstrato o nível do teste \cite{sommerville2007}. Os testes de software são divididos da seguinte forma, em ordem descrescente de abstração:
\begin{description}
\item[Testes de aceitação:] são testes cuja finalidade é garantir que as especificações do software foram implementadas, de forma a corresponder com as necessidades do usuário final. Em essência, é um teste de validação dos software. \cite{sommerville2007}.
\item[Testes de sistema:] tipo de teste que visa observar se o sistema funciona por completo. Diferentemente do testes aceitação seu foco não é a experiência do usuário, mas se o sistema é seguro, responde as requisições \cite{sommerville2007}.
\item[Testes de Integração:] faz a análise e identificação de defeitos relacionados à integração de dois ou mais componentes do software. Normalmente visam as \textit{interfaces} que interagem com esses componentes \cite{sommerville2007}.
\item[Testes de Unidade:] é o processo de teste de partes específicas do código-fonte. Busca a seleção de partes pequenas, mas de valor sifnigicativo, do código para fazer o teste. Normalmente os métodos (ou funções-membro) são consideradas unidades. Essa análise possibilita a verificação código, de forma a identificar defeitos e mitigá-los \cite{sommerville2007}.
\end{description}
\par
\indent Os testes podem também ser classificados como: testes caixa-preta e testes caixa-branca \cite{barbosaEtAl2009}.

\subsection{Testes Caixa-preta}
Testes caixa-preta, também conhecidos como testes baseados em especificações, visam a avaliação do produto em relação aos requisitos funcionais e não funcionais. É caracterizado por fazer análises a partir de documentação e do software em funcionamento, sem necessidade de averiguação do código-fonte \cite{barbosaEtAl2009}.

\begin{figure}[h]
  \centering
    \includegraphics[width=0.8\textwidth]{figuras/test_black_box.png}
    \caption{Diagrama Representativo de Testes Caixa Preta}
    \label{test_black_box}
\end{figure}

A Figura \ref{test_black_box} representa um esquemático do funcionamento de um teste caixa-preta: utiliza-se dados de entrada no software e observa-se a correspondência, ou não, com as expectativas.
\par
\indent Ao utilizar-se de testes caixa-preta desenvolve-se os testes do ponto de vista do usuário, o que auxilia a observar alguma falha nas especificações. Além disso, permite que os casos de teste possam ser produzidos assim que as especificações estiverem prontas \cite{stf2010}. Essa abordagem de testes também possui pontos negativos, como a pequena quantidade de entradas que podem ser inseridas para testar o produto. Sem especificações claras produzir bons casos de testes caixa-preta torna-se uma tarefa difícil \cite{stf2010}.

\subsubsection{Técnicas de Derivação de Casos de Teste Caixa-preta}
Testes caixa-preta não são o foco deste trabalho. Dessa forma, apenas um \textit{overview} das técnicas para essa abordagem de testes será abordado. Para a concepção de casos de testes caixa-preta há algumas técnicas utilizadas como guias. São elas: \textbf{classes de equivalência}, \textbf{análise de valores limite} e \textbf{grafo de causa e efeito}.

\begin{description}
\item[Classes de equivalência:] visa a identificação de agrupamentos de casos de testes que cubram diferentes classes de erros. Essa estratégia permite a redução do número de testes que serão produzidos, diminuindo os custos. A técnica de classes de equivalência divide as entradas do domínio do software em classes. Essas classes devem ser derivadas a partir de um valor significativo para o domínio \cite{williams2006}.
\item[Análise de valores limite:] um ponto crítico, e já observado por especialistas, é que grande parte dos defeitos no código são inseridos nos limites de uma classe de equivalência. Isso permite a conclusão de que o principal foco no caso de teste deve ser sobre os valores limites. Entende-se como \textbf{limite} um valor que esteja imediatamente próximo ao valor de entrada significativo que divide o domínio em classes de equivalência. Sendo assim, num contexto onde o valor significativo, para separar duas classes de equivalência, seja 50, possíveis valores limite seriam 49 e 51 \cite{williams2006}.
\item[Grafo de causa e efeito:] é uma representação visual das relações entre as entradas e saídas. Permite a observação lógico-combinatória das especificações do programa. É uma representação semelhante a circuitos lógicos. Sua principal vantagem é a visualização que se dá, permitindo identificar casos de teste muito facilmente. No entanto, quando a rede fica muito grande e complexa, passa a ser considerado o uso de outras técnicas \cite{barbosaEtAl2009}.
\end{description}


\subsection{Testes Caixa-branca}
Testes de caixa-branca, também referenciados como testes baseados em programa, almejam a avaliação do produto por meio da execução do código-fonte. Isso possibilita o exercício do software em busca de defeitos para serem corrigidos. Para que ocorra a dinâmica de testes de caixa-branca seleciona-se casos de testes que englobem cenários significativos \cite{barbosaEtAl2009}.
\par
\indent Algumas vantagens de teste de caixa-branca podem ser listadas: pode-se dar início ao desenvolvimento de testes desde o começo da codificação, na medida em que a interação com interfaces não é necessária. Além disso, é um tipo de teste capaz de cobrir mais caminhos, pois tem um alcance mais profundo no software. Com relação aos pontos negativos, cita-se a necessidade de programadores para efetuar os testes de caixa-branca \cite{barbosaEtAl2009}.

\subsection{Técnicas de Derivação de Casos de teste Caixa-branca}
Os testes de caixa-branca são utilizados objetivando que todos os caminhos independentes possam ser percorridos e testados. Algumas técnicas para derivação de casos de teste são utilizadas, com o intuito de garantir que todos os caminhos tenham sido percorridos, pelo menos um vez, e assegurar uma quantidade de teste exclusivamente necessária. São elas: \textbf{Cobertura de Comandos}, \textbf{Cobertura de Decisão}, \textbf{Cobertura de Condição} e \textbf{Cobertura de Decisão-condição} \cite{istqb2014}.

\begin{description}
\item[Cobertura de comandos:] também conhecido como cobertua de linha ou cobertura de segmento. Tem por propósito a execução de todos os comandos do código, ao menos uma vez. Caracteriza-se por cobrir unicamente as linhas com condição verdadeira, e por permitir a observação dos comandos que, por algum motivo, não estão sendo executados. É considerada uma estrátegia incompleta, pois não permite o teste de condições falsas, muito menos a execução de testes de \textit{loops} de forma a ter-se certeza de sua condição de término \cite{istqb2014}.
\item[Cobetura de Decisão:] semelhante à técnica de cobertura de comando, entretanto, desenhado para que tanto as condições verdadeiras quanto as falsas sejam cobertas pelos casos de teste. Da mesma forma que a cobertura de comando, pode deixar de identificar defeitos, pois cobrir uma linha de código não garante que o comando esteja livre de defeitos. Tamem é chamado de cobertura de ramificações. \cite{istqb2014}.
\item[Cobertura de Condição:] define-se por ser uma estratégia mais sensível aos possíveis caminhos no fluxo de controle. Busca cobrir todos os possíveis valores significativos relativos a uma condição no fluxo \cite{istqb2014}.
\item[Cobertura de Decisão-condição:] é uma estratégia que pretende unir as vantagens da cobertura de decisão e de condição \cite{istqb2014}.
\end{description}
\par
\indent Utilizando-se de um grafo de fluxo de controle fica mais fácil a visualização e identificação dos caminhos a serem testados \cite{copeland2003}.

\section{\textit{Frameworks}}
\textit{Frameworks} podem ser definidos como uma forma de reutilização de software. \textit{Frameworks} são um conjunto de objetos e classes, abstratas e/ou concretas, que constitui uma arquitetura especializada a solucionar uma família de problemas \cite{barretoJunior2006}. Esse tipo de solução para o reuso de software, um dos principais objetivos da Engenharia de Software, é, em essência, uma aplicação não plenamente concluída, mas instanciável, e que permite adaptações no código para um funcionamento específico, visando a solução de um problema dentro do domínio englobado pelo \textit{framework} \cite{barretoJunior2006}.
\par
\indent Dentre as características de um \textit{framework} pode-se destacar \cite{sauve2006}:
\begin{itemize}
\item Provê solução para problemas com um mesmo domínio.
\item Possui arquitetura baseada em classes e interfaces que abstraem o domínio.
\item É flexível e extensível.
\end{itemize}
\par
\indent Durante o desenvolvimento de software a reutilização de soluções é uma prática bastante comum. Há diversas formas de colocar em prática o reuso, como por exemplo o uso de \textbf{\textit{framewokrs}}, \textbf{bibliotecas} e \textbf{\textit{design patterns}}. Essas formas de reuso de software, em alguns momentos, podem ser semelhantes, no entanto, são técnicas distintas \cite{sauve2006}.
\par
\indent Os três modos de reutilização de software possuem pontos parecidos, como refletir abstrações, generalizando um domínio de problemas e demonstrando uma solução (\textit{frameworks} e \textit{design pattern}), ou mesmo configurando-se como um conjunto de classes capazes de dar suporte ao desenvolvedor com soluções já pensadas e implementadas (\textit{frameworks} e bibliotecas de classes e/ou funções).
\par
\indent Da mesma forma, há também pontos que diferenciam esses tipos de reuso de software.
  \begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figuras/bibFrameworkDesignPattern.png}
    \caption{Diferença entre Formas de Reuso de Software}
    \label{fig:bibFrameworkPattern}
  \end{figure}
\par
\indent A Figura \ref{fig:bibFrameworkPattern} esquematiza algumas diferenças, bem como conceitos desses modos de reuso de software. Como demonstrado na Figura \ref{fig:bibFrameworkPattern}, biliotecas de classes possuem componentes, classes e/ou funções, já prontos, da mesma forma que \textit{frameworks}, entretanto, não há conexão entre eles. São independentes. Em \textit{frameworks} as classes que o compõe possuem dependências já encravadas por seu projetista, de forma que o modelo de colaboração entre elas já está embutido, enquanto que ao utilizar-se de uma biblioteca o desenvolvedor deve criar por si só esse modelo de colaboração, caso necessário \cite{sauve2006}.
\par
\indent \textit{Frameworks}, em contra ponto às bibliotecas de classe, é que está responsável por fazer chamadas ao código da aplicação a qual está vinculado. A essa forma de relação dá-se o nome de \textit{Hollywood Principle} (\textit{"don't call us, we'll call you"}) \cite{sauve2006}.
\par
\indent Uma outra diferença entre \textit{frameworks}, bibliotecas e \textit{design patterns} é que no  primeiro caso é previsto a justaposição de conhecimento de domínio, enquanto que nos demais casos não é previsto isso \cite{sauve2006}.
% Geração de Testes
% Resumo do Capítulo